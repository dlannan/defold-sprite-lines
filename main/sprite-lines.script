-- main.script

-- Requires:
-- A line.go with a sprite component:
--     Image: 1x1 white pixel
--     Atlas: /assets/line.atlas
-- A line_factory pointing to that line.go
-- The main.script attached to a main.collection

local tinsert = table.insert

local LINE_COUNT    = 50000
local LINE_LENGTH   = 50
local LINE_WIDTH    = 15
local DEPTH_SCALE   = 0.01

local WIDE          = 20 
local WIDE_HALF     = WIDE / 2 
local HIGH          = 20 
local HIGH_HALF     = HIGH / 2
local DEPTH         = 20

local LINES_MESH = {
    { "/line_buffer1#lines_mesh", "lines1" },
    { "/line_buffer2#lines_mesh", "lines2" },
    { "/line_buffer3#lines_mesh", "lines3" },
}

-- Simple way to manage resource usage
local resource_pool = {}

-- Placeholder texture for the line (1x1 white pixel)
-- You can replace this with a proper texture atlas
local LINE_TEXTURE = "/assets/lines/line.atlas"

-- List of line objects
local function make_lines(self)
    self.lines = {}
    -- Seed random
    math.randomseed(os.time())

    -- Create 10K line game objects
    for i = 1, LINE_COUNT do
        local angle = math.random() * 2 * math.pi
        local length = LINE_LENGTH + math.random() * 100
        local pos = vmath.vector3(math.random() * 10 - 5, math.random() * 10 - 5, -10)

        -- Create a line instance
        local id = factory.create("/main#line_factory", pos, vmath.quat_rotation_z(angle))

        -- Set scale to length and width
        go.set_scale(vmath.vector3(length, LINE_WIDTH, 1) * DEPTH_SCALE, id)

        -- Save for later (optional)
        tinsert(self.lines, id)
    end
end    

local function set_vertex(self, index, vertex, color)
    self.line_pos_stream[index + 1] = vertex.x
    self.line_pos_stream[index + 2] = vertex.y
    self.line_pos_stream[index + 3] = vertex.z
    
    self.line_pos_stream[index + 4] = color
end

-- Make a buffer of quads. Each quad (two tris) is a line. The buffer contains only color and posiiton - no textures.
local function make_lines_mesh(self, mesh_url)

    local mesh_name = mesh_url[2]
    self.res[mesh_name] = go.get(mesh_url[1], "vertices")
    pprint(self.res[mesh_name])

    self.line_buffer[mesh_name] = buffer.create(LINE_COUNT * 6, {
        { name = hash("position"), type = buffer.VALUE_TYPE_FLOAT32, count = 4 },
    })

    -- local name = "/runtime_buffer_lines.bufferc"
    -- local new_buffer = resource.create_buffer(name, { buffer = self.line_buffer[mesh_url] })
    self.buffer_created[mesh_url] = true

    local buffer_name = string.format("/assets/buffers/line_buffer_%s.bufferc", mesh_name)
    local resource_buffer = nil
    if(resource_pool[buffer_name] == nil) then 
        resource_buffer = resource.create_buffer(buffer_name, { buffer = self.line_buffer[mesh_name]  })
        resource_pool[buffer_name] = resource_buffer
    else 
        resource_buffer = resource_pool[buffer_name]
    end
    go.set(mesh_url[1], "vertices",  resource_buffer)    
end

local function set_lines_data(self, mesh_url)

    local mesh_name = mesh_url[2]
    self.line_pos_stream = buffer.get_stream(self.line_buffer[mesh_name], hash("position"))

    for i = 0, LINE_COUNT-1 do
        local angle = math.random() * 2 * math.pi
        local length = LINE_LENGTH + math.random() * 100
        -- TODO: Make a better random pos?
        local pos = vmath.vector3(math.random() * WIDE - WIDE_HALF, math.random() * HIGH - HIGH_HALF, -DEPTH)

        local b = math.floor(math.random(255)) 
        local g = math.floor(math.random(255))
        local r = math.floor(math.random(255))
        
        local color = (r + g * 256 + b * 65536) / ( 256 * 256 * 256 )

        local rot = vmath.quat_rotation_z(angle)
        
        -- Set scale to length and width
        local len1 = vmath.vector3(length, -LINE_WIDTH * 0.5, 0) * DEPTH_SCALE
        local len2 = vmath.vector3(length, LINE_WIDTH * 0.5, 0) * DEPTH_SCALE
        local len3 = vmath.vector3(0.0, LINE_WIDTH * 0.5, 0) * DEPTH_SCALE
        local len4 = vmath.vector3(0.0, -LINE_WIDTH * 0.5, 0) * DEPTH_SCALE
        
        local endpos1 = pos + vmath.rotate(rot, len1)
        local endpos2 = pos + vmath.rotate(rot, len2)
        local endpos3 = pos + vmath.rotate(rot, len3)
        local endpos4 = pos + vmath.rotate(rot, len4)

        local index = i * 6 * 4
        set_vertex( self, index + 0, endpos4, color )
        set_vertex( self, index + 1 * 4, endpos1, color )
        set_vertex( self, index + 2 * 4, endpos2, color )
        set_vertex( self, index + 3 * 4, endpos4, color )
        set_vertex( self, index + 4 * 4, endpos2, color )
        set_vertex( self, index + 5 * 4, endpos3, color )
    end    

    -- go.set(LINES_MESH, "vertices", self.line_buffer)    
    resource.set_buffer(self.res[mesh_name], self.line_buffer[mesh_name])
end

function reset(self)
    -- release all the lines and do it again 
    for k,v in ipairs(LINES_MESH) do
        set_lines_data(self, v)
    end 
end

function init(self)
    self.res             = {}
    self.line_buffer     = {}
    self.buffer_created  = {}
    for k,v in ipairs(LINES_MESH) do
        make_lines_mesh(self, v)
    end
    reset(self)
end

function on_message(self, message_id, message, sender)

    if message_id == hash("clear") then 
        -- Delete the instances
        -- for i,l in ipairs(self.lines) do go.delete(l, true) end
        msg.post("/main", "reset")
    elseif message_id == hash("reset") then 
        reset(self)
    end
end